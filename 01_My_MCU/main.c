//*******************************************************************************************
//*******************************************************************************************
/*
 * 
 *
 * Created: 
 * Author : 
 */ 
//*******************************************************************************************
//*******************************************************************************************

#include "main.h"

//*******************************************************************************************
//*******************************************************************************************

volatile uint8_t sleepReg = 0;

//*******************************************************************************************
//*******************************************************************************************
void Sllep(void){
	
	//Инициализация ножки PD2(INT0) для генерации прерывания.
	DDRD  &= ~(1<<PIND2);//настраиваем вывод на вход
	PORTD |=  (1<<PIND2);//включаем подтягивающий резистор
		
	MCUCR |= (0<<ISC01)|(0<<ISC00);//The low level of INT0 generates an interrupt request.
	GICR  |= (1<<INT0);			   //разрешаем внешнее прерывание на int0
		
	sleepReg = 1;
		
	//set_sleep_mode(SLEEP_MODE_PWR_DOWN);
	MCUCR |= SLEEP_MODE_PWR_DOWN;//
		
	//sleep_enable();
	MCUCR |= 1<<SE;
		
	sei();
	sleep_cpu();
		
	//sleep_disable()
	MCUCR &= ~(1<<SE);//
		
	GICR &= ~(1<<INT0); //Отключение внешнего прерывания на int0
	//cli();
}
//*******************************************************************************************
//*******************************************************************************************

#include <compat/deprecated.h>

void asm_TogglePin(void){
	
	//
	//register unsigned char counter asm("r3");
	//
	//__asm__ __volatile__("clr r3"		"\n\t" \
						//"in %r1, 12"	"\n\t" \
						//: [tempReg] "=&d"
						//);
}
//*******************************************************************************************
//*******************************************************************************************
const uint8_t string1[] PROGMEM = {1, 2, 3, 4, 5};
//const uint8_t string1[] = {1, 2, 3, 4, 5};



//Основной цикл программы.
int main(void){
	
	//uint8_t temp  = 0;
	//------------------------------
	//Sllep();
	//------------------------------
	//_delay_ms(1000);//Пауза для стабилизации переходных процессов.
	//------------------------------
	//relay_em_init();//Отключение УМ.
	Timers_Init();	
	USART_Init();
	I2C_Init();
	//----------------------------------------------------------------------
	//Включение сторожевого таймера со сбросом через 2 секунды. 
	//wdt_enable(WDTO_2S);

	//сброс сторожевого таймера
	//wdt_reset();
	//----------------------------------------------------------------------	
	//Глобальное разрешение прерываний.
	sei();
	
	
	lcd_init();
	
	uint8_t chr1 = pgm_read_byte(&string1[0]);
	//uint8_t chr1 = string1[0];
	chr1++;
	//----------------------------------------------------------------------
//	_delay_ms(1000);							 //Пауза для стабилизации переходных процессов.

	//----------------------------------------------------------------------
	//Считывание конфигурации из ЕЕПРОМ.
	//eep_read_configuration(&ConfigurationStr);
	////Если в ЕЕПРОМ отсутствует конфигурация то запишем конфигурацию по умолчанию. 
	//if (ConfigurationStr.STR.Address > MAX_ADDRESS)//Если в EEPROM 0хFF, значит конфигурация еще не записывалась. 
		//{
			////Конфигурации по умолчанию.
			//ConfigurationStr.STR.Address		= ADDRESS_DEFAULT;
			//ConfigurationStr.STR.Group			= GROUP_DEFAULT;
			//ConfigurationStr.STR.ChargeCheck	= CHARGE_CHECK_DEFAULT;
			//ConfigurationStr.STR.RS485Check		= RS485_CHECK_DEFAULT;
			//ConfigurationStr.STR.TimeAutoCheck	= TIMEOUT_CHECK_DEFAULT;
			//ConfigurationStr.STR.Buzzer			= BUZZER_OFF; 
			//ConfigurationStr.STR.LevelLC		= LEVEL_LC_DEFAULT; 
////			ConfigurationStr.STR.Reservation	= RESERVATION_DEFAULT; 
			//eep_write_configuration(&ConfigurationStr);
			//eep_write_set_lines_to_control(0xFF);//При первом включении прибора все линии Установленны на контроль.
		//}
	//---------------------------------------------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------------------------------------------
	//uint8_t TextBuf[] = "123456789\n";
	//uint8_t	i2c_TxBuf[] = "1234567890";
	uint16_t n = 0;
	

	while (1)
	{
		//RX_LED_PORT ^= RX_LED;
		//USART_StartTX(TextBuf, sizeof(TextBuf)-1);

//		I2C_SetState(I2C_FREE);	// Освобождаем шину	
//		I2C_StartWrite(LCD_I2C_ADDRESS, 0x0000, i2c_TxBuf, sizeof(i2c_TxBuf)-1);
//		msDelay(1000);

		RX_LED_PORT ^= RX_LED;
		
		//I2C_SetState(I2C_FREE);	// Освобождаем шину	
		lcd_set_cursor(LCD_STRING_1, 1);
		//lcd_print_string("123456");
		lcd_BinToDec(n++, 4);
		
		msDelay(1000);
		//************************************************************
		//asm_TogglePin();
		
		
		//************************************************************
	}
	//---------------------------------------------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------------------------------------------	
}
//*******************************************************************************************
//*******************************************************************************************
//Обработчик внешнего прерывания INT0(PD2).
ISR(INT0_vect){
	
	//uint8_t i     = 0;
	//uint8_t count = 0;
	//
	//while(++i >= 16)
	//{
		//if ((PIND & (1<<PIND2)) == 0) count++;
	//}
	//if (count > 10) sleepReg = 0;
	
	if ((PIND & (1<<PIND2)) == 0) sleepReg = 0;
	//sleep_disable();
	
	//RX_LED_PORT |= RX_LED;
}
//*******************************************************************************************
//*******************************************************************************************



