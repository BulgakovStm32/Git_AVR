//*******************************************************************************************
//*******************************************************************************************
/*
 * 
 *
 * Created: 
 * Author : 
 */ 
//*******************************************************************************************
//*******************************************************************************************

#include "main.h"

//*******************************************************************************************
//*******************************************************************************************

volatile uint8_t sleepReg = 0;

//*******************************************************************************************
//*******************************************************************************************
void Sllep(void){
	
	//Инициализация ножки PD2(INT0) для генерации прерывания.
	DDRD  &= ~(1<<PIND2);//настраиваем вывод на вход
	PORTD |=  (1<<PIND2);//включаем подтягивающий резистор
		
	MCUCR |= (0<<ISC01)|(0<<ISC00);//The low level of INT0 generates an interrupt request.
	GICR  |= (1<<INT0);			   //разрешаем внешнее прерывание на int0
		
	sleepReg = 1;
		
	//set_sleep_mode(SLEEP_MODE_PWR_DOWN);
	MCUCR |= SLEEP_MODE_PWR_DOWN;//
		
	//sleep_enable();
	MCUCR |= 1<<SE;
		
	sei();
	sleep_cpu();
		
	//sleep_disable()
	MCUCR &= ~(1<<SE);//
		
	GICR &= ~(1<<INT0); //Отключение внешнего прерывания на int0
	//cli();
}
//*******************************************************************************************
//*******************************************************************************************

#include <compat/deprecated.h>

void asm_TogglePin(void){
	
	//
	//register unsigned char counter asm("r3");
	//
	//__asm__ __volatile__("clr r3"		"\n\t" \
						//"in %r1, 12"	"\n\t" \
						//: [tempReg] "=&d"
						//);
}
//*******************************************************************************************
//*******************************************************************************************
//Основной цикл программы.
int main(void){
	
	//uint8_t temp  = 0;
	//------------------------------
	//Sllep();
	//------------------------------
	//_delay_ms(1000);//Пауза для стабилизации переходных процессов.
	//------------------------------
	//relay_em_init();//Отключение УМ.
	Timers_Init();	
	USART_Init();
	I2C_Init();
	//----------------------------------------------------------------------
	//Включение сторожевого таймера со сбросом через 2 секунды. 
	//wdt_enable(WDTO_2S);

	//сброс сторожевого таймера
	//wdt_reset();
	//----------------------------------------------------------------------	
	//Глобальное разрешение прерываний.
	sei();
	
	
	lcd_init();
	//----------------------------------------------------------------------
//	_delay_ms(1000);							 //Пауза для стабилизации переходных процессов.
//	calibration_adc_for_line_checker();			 //Автокалибровка измерительного канала АЦП LineCheckera при включении.
	//----------------------------------------------------------------------
	//Красивое включение.
	//set_relay(ALL_RELAY_OFF, SPEAKER_RELAY);//Отключение всех линий от УМ.
	//for (temp = 0; temp < 9; temp++)
		//{
			//set_speaker_led_green((1 << (8 - temp)));
			//ms_delay(60);
		//}
//
	//for (temp = 0; temp < 8; temp++)
		//{
			//set_speaker_led_green(1 << temp);
			//ms_delay(60);
		//}
	//set_speaker_led_green(ALL_LED_OFF);//Гасим все зеленые светодиоды. 	
	//----------------------------------------------------------------------
	//Считывание конфигурации из ЕЕПРОМ.
	//eep_read_configuration(&ConfigurationStr);
	////Если в ЕЕПРОМ отсутствует конфигурация то запишем конфигурацию по умолчанию. 
	//if (ConfigurationStr.STR.Address > MAX_ADDRESS)//Если в EEPROM 0хFF, значит конфигурация еще не записывалась. 
		//{
			////Конфигурации по умолчанию.
			//ConfigurationStr.STR.Address		= ADDRESS_DEFAULT;
			//ConfigurationStr.STR.Group			= GROUP_DEFAULT;
			//ConfigurationStr.STR.ChargeCheck	= CHARGE_CHECK_DEFAULT;
			//ConfigurationStr.STR.RS485Check		= RS485_CHECK_DEFAULT;
			//ConfigurationStr.STR.TimeAutoCheck	= TIMEOUT_CHECK_DEFAULT;
			//ConfigurationStr.STR.Buzzer			= BUZZER_OFF; 
			//ConfigurationStr.STR.LevelLC		= LEVEL_LC_DEFAULT; 
////			ConfigurationStr.STR.Reservation	= RESERVATION_DEFAULT; 
			//eep_write_configuration(&ConfigurationStr);
			//eep_write_set_lines_to_control(0xFF);//При первом включении прибора все линии Установленны на контроль.
		//}
	//----------------------------------------------------------------------
	//Управление светодиодом POWER.
	//if((POWER_SWITCH_PIN & POWER_SWITCH_LEG) == 0)
		//{
			////Клавиша в положении ON.
			//power_led_green();									   //Зеленый светодиод POWER.
			//display_set( bin_to_dec(ConfigurationStr.STR.Address));//Вывод установленного адреса на дисплей.
		//}			
	//else
		//{
			////Клавиша в положении OFF.
			//power_led_blink_green();								//Мигающий зеленый светодиод POWER.
		//}	
	//----------------------------------------------------------------------
	//Измерение импеданса 8-ми линий. Если импеданс линии выходит за рамки максимума или
	//минимума, то это значение не сохраняется. Если КЗ, то индикация мигающий желтый и включение звуковой индикации.
//	measure_resistence_all_line_after_power_on(ConfigurationStr.STR.LevelLC);
	//----------------------------------------------------------------------
	//Считывание из EEPROM установленных на контроль линий. 
//	set_lines_to_control(eep_read_set_lines_to_control());  
	//----------------------------------------------------------------------
	//Принудительне обесточивание реле SP и LC.
	//set_relay(ALL_RELAY_OFF, SPEAKER_RELAY);	 //Отключение всех линий от УМ.
	//set_relay(ALL_RELAY_OFF, LINE_CHECKER_RELAY);//Отключение реле LC от громкоговорителей.
	//----------------------------------------------------------------------
	//Конфигурация блока для работы протокола и запуск протокола.
//	usart_config_for_protocol(&ConfigurationStr);
	//---------------------------------------------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------------------------------------------
	//uint8_t TextBuf[] = "123456789\n";
	//uint8_t	i2c_TxBuf[] = "1234567890";
	uint16_t n = 0;
	

	while (1)
	{
		//RX_LED_PORT ^= RX_LED;
		//USART_StartTX(TextBuf, sizeof(TextBuf)-1);

//		I2C_SetState(I2C_FREE);	// Освобождаем шину	
//		I2C_StartWrite(LCD_I2C_ADDRESS, 0x0000, i2c_TxBuf, sizeof(i2c_TxBuf)-1);
//		msDelay(1000);

		RX_LED_PORT ^= RX_LED;
		
		//I2C_SetState(I2C_FREE);	// Освобождаем шину	
		lcd_set_cursor(LCD_STRING_1, 1);
		//lcd_print_string("123456");
		lcd_BinToDec(n++, 4);
		
		msDelay(1000);
		//************************************************************
		//asm_TogglePin();
		
		
		//************************************************************
	}
	//---------------------------------------------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------------------------------------------	
}
//*******************************************************************************************
//*******************************************************************************************
//Обработчик внешнего прерывания INT0(PD2).
ISR(INT0_vect){
	
	//uint8_t i     = 0;
	//uint8_t count = 0;
	//
	//while(++i >= 16)
	//{
		//if ((PIND & (1<<PIND2)) == 0) count++;
	//}
	//if (count > 10) sleepReg = 0;
	
	if ((PIND & (1<<PIND2)) == 0) sleepReg = 0;
	//sleep_disable();
	
	//RX_LED_PORT |= RX_LED;
}
//*******************************************************************************************
//*******************************************************************************************



